````markdown
# CODEX TASK — Add ROAD + RIVER network generation + UI overlay wiring (expandable)
Repo: `/mnt/data/taktik_src` (from `taktik.zip`)

You said: runtime uses only `public/assets/tiles/ground.png` right now. Keep that.  
Goal: generate **network overlay tiles** (PNG with transparency) for **ROAD** and **RIVER** that **join perfectly** across tiles, and wire a minimal UI-only demo so we can see it on the board.

✅ UI-only. Do NOT touch engine logic/reducers/phases.

---

## 0) Current situation (do not break)
- Board renders ground tiles via `src/components/IsometricBoard.tsx` using `/assets/tiles/ground.png`.
- Highlight uses `/assets/tiles/highlight_move.png`.
- Tiles are generated by `scripts/gen_terrain_tiles.mjs` (PNGJS), then you sometimes crop manually.
- There is no terrain model in engine state.

We will:
1) Extend `scripts/gen_terrain_tiles.mjs` to generate network overlay PNGs:
   - `public/assets/tiles/networks/road_<EDGES>.png`
   - `public/assets/tiles/networks/river_<EDGES>.png`
2) Add UI-only network data + adjacency algorithm:
   - `src/lib/ui/networks.ts`
3) Wire overlays into `src/components/IsometricBoard.tsx` (still ground-only base).

---

## 1) Extend the generator: `scripts/gen_terrain_tiles.mjs`

### 1.1 Create folder
Write overlays into:
`public/assets/tiles/networks/`

Add:
```js
const NETWORK_DIR = path.join(OUT_DIR, "networks");
ensureDir(NETWORK_DIR);
````

### 1.2 Add edge utilities (stable naming)

Add near top:

```js
const EDGE_ORDER = ["N", "E", "S", "W"];

function edgeKey(edges) {
  if (!edges || edges.length === 0) return "NONE";
  const set = new Set(edges);
  return EDGE_ORDER.filter((e) => set.has(e)).join("");
}
```

### 1.3 Add a fast “top-face diamond mask”

We must guarantee overlays never paint outside the **top diamond face** (no seams, no side faces).
Add:

```js
function applyTopFaceMask(png, cx, cy, tileW, tileH) {
  const halfW = tileW / 2;
  const halfH = tileH / 2;

  const minX = Math.floor(cx - halfW);
  const maxX = Math.ceil(cx + halfW);
  const minY = Math.floor(cy - halfH);
  const maxY = Math.ceil(cy + halfH);

  for (let y = minY; y <= maxY; y += 1) {
    for (let x = minX; x <= maxX; x += 1) {
      // diamond test: |dx|/halfW + |dy|/halfH <= 1
      const dx = Math.abs(x - cx);
      const dy = Math.abs(y - cy);
      const inside = dx / halfW + dy / halfH <= 1;
      if (!inside) {
        const idx = (y * png.width + x) * 4;
        if (idx >= 0 && idx + 3 < png.data.length) {
          png.data[idx + 3] = 0;
        }
      }
    }
  }
}
```

### 1.4 Add helpers to draw connector strips (axis-aligned in screen space)

In your tile math, top/right/bottom/left are diamond corners and **center-to-edge is axis aligned**:

* N/S = vertical strips
* E/W = horizontal strips

Add:

```js
function fillRect(png, x0, y0, x1, y1, color) {
  // inclusive bounds
  const minX = Math.max(0, Math.floor(Math.min(x0, x1)));
  const maxX = Math.min(png.width - 1, Math.ceil(Math.max(x0, x1)));
  const minY = Math.max(0, Math.floor(Math.min(y0, y1)));
  const maxY = Math.min(png.height - 1, Math.ceil(Math.max(y0, y1)));

  for (let y = minY; y <= maxY; y += 1) {
    for (let x = minX; x <= maxX; x += 1) {
      setPixel(png, x, y, color);
    }
  }
}
```

### 1.5 Implement overlay tile factory (shared by road/river)

Add:

```js
function makeNetworkOverlayTopFace({ edges, kind, widthPx, color, innerColor }) {
  const size = 1024 * SCALE;
  const png = new PNG({ width: size, height: size });
  png.data.fill(0);

  const cx = size / 2;
  const cy = 430 * SCALE;

  const tileW = 640 * SCALE;
  const tileH = 320 * SCALE;

  const topY = cy - tileH / 2;
  const bottomY = cy + tileH / 2;
  const leftX = cx - tileW / 2;
  const rightX = cx + tileW / 2;

  const half = widthPx / 2;

  // Always draw a center join plate so corners/T/X look welded.
  // Road uses this strongly; river uses it too to avoid “pinholes”.
  if (kind === "stroke") {
    // ROAD: optional two-layer stroke (outer + inner) for crispness; still flat.
    // Outer
    fillRect(png, cx - half, cy - half, cx + half, cy + half, color);
    if (innerColor) {
      const innerHalf = Math.max(1, Math.floor(half * 0.68));
      fillRect(png, cx - innerHalf, cy - innerHalf, cx + innerHalf, cy + innerHalf, innerColor);
    }
  } else {
    // RIVER: filled channel; optional inner channel for “banks” (still flat, no texture).
    fillRect(png, cx - half, cy - half, cx + half, cy + half, color);
    if (innerColor) {
      const innerHalf = Math.max(1, Math.floor(half * 0.70));
      fillRect(png, cx - innerHalf, cy - innerHalf, cx + innerHalf, cy + innerHalf, innerColor);
    }
  }

  const edgeSet = new Set(edges);

  function drawArmN() {
    fillRect(png, cx - half, topY, cx + half, cy, color);
    if (innerColor) {
      const innerHalf = Math.max(1, Math.floor(half * 0.70));
      fillRect(png, cx - innerHalf, topY, cx + innerHalf, cy, innerColor);
    }
  }
  function drawArmS() {
    fillRect(png, cx - half, cy, cx + half, bottomY, color);
    if (innerColor) {
      const innerHalf = Math.max(1, Math.floor(half * 0.70));
      fillRect(png, cx - innerHalf, cy, cx + innerHalf, bottomY, innerColor);
    }
  }
  function drawArmE() {
    fillRect(png, cx, cy - half, rightX, cy + half, color);
    if (innerColor) {
      const innerHalf = Math.max(1, Math.floor(half * 0.70));
      fillRect(png, cx, cy - innerHalf, rightX, cy + innerHalf, innerColor);
    }
  }
  function drawArmW() {
    fillRect(png, leftX, cy - half, cx, cy + half, color);
    if (innerColor) {
      const innerHalf = Math.max(1, Math.floor(half * 0.70));
      fillRect(png, leftX, cy - innerHalf, cx, cy + innerHalf, innerColor);
    }
  }

  if (edgeSet.has("N")) drawArmN();
  if (edgeSet.has("S")) drawArmS();
  if (edgeSet.has("E")) drawArmE();
  if (edgeSet.has("W")) drawArmW();

  // HARD GATE: nothing outside the top diamond.
  applyTopFaceMask(png, cx, cy, tileW, tileH);

  return png;
}
```

### 1.6 Generate all variants for ROAD + RIVER (expandable registry)

Add a registry so we can add “trench” later with one entry.

Add:

```js
const NETWORKS = [
  {
    id: "road",
    kind: "stroke",
    // width relative to tileW; tuned for readability after scaling to TILE_W/TILE_H
    widthPx: Math.round(640 * SCALE * 0.045),
    // dark neutral road, flat
    color: [70, 70, 66, 210],
    // optional inner lane to keep edges crisp without strokes
    innerColor: [92, 92, 88, 210],
  },
  {
    id: "river",
    kind: "channel",
    widthPx: Math.round(640 * SCALE * 0.060),
    // muted blue-green, flat (board-passive)
    color: [66, 96, 98, 200],
    // inner channel (banks impression, still flat)
    innerColor: [86, 118, 120, 200],
  },
];
```

Then generate all non-empty edge subsets (15 variants):

```js
const EDGE_SUBSETS = [];
for (let mask = 1; mask < 16; mask += 1) {
  const edges = [];
  if (mask & 1) edges.push("N");
  if (mask & 2) edges.push("E");
  if (mask & 4) edges.push("S");
  if (mask & 8) edges.push("W");
  EDGE_SUBSETS.push(edges);
}

for (const net of NETWORKS) {
  for (const edges of EDGE_SUBSETS) {
    const key = edgeKey(edges); // e.g. "NE", "NSW", "NESW"
    const png = makeNetworkOverlayTopFace({
      edges,
      kind: net.kind,
      widthPx: net.widthPx,
      color: net.color,
      innerColor: net.innerColor,
    });
    writePng(path.join(NETWORK_DIR, `${net.id}_${key}.png`), png);
  }
}

console.log("Generated network overlays:", NETWORKS.map(n => n.id).join(", "));
```

✅ Result files:

* `/public/assets/tiles/networks/road_N.png`, `road_NE.png`, ... `road_NESW.png`
* `/public/assets/tiles/networks/river_N.png`, ... `river_NESW.png`

These are top-face-only overlays and will join perfectly because:

* geometry is connector-driven
* edges are identical per direction
* masking guarantees no paint outside diamond

---

## 2) Add UI-only adjacency algorithm + naming: `src/lib/ui/networks.ts`

Create `src/lib/ui/networks.ts`:

```ts
export type Edge = "N" | "E" | "S" | "W";
export type Cell = { x: number; y: number };

export type NetworkConnectors = {
  road?: Edge[];
  river?: Edge[];
};

const ORDER: Edge[] = ["N", "E", "S", "W"];

export function edgeKey(edges?: Edge[]): string | null {
  if (!edges || edges.length === 0) return null;
  const set = new Set(edges);
  return ORDER.filter((e) => set.has(e)).join("");
}

function keyOf(x: number, y: number) {
  return `${x},${y}`;
}

export function deriveEdges(cells: Cell[]): Map<string, Edge[]> {
  const set = new Set(cells.map((c) => keyOf(c.x, c.y)));
  const out = new Map<string, Edge[]>();

  for (const c of cells) {
    const edges: Edge[] = [];
    if (set.has(keyOf(c.x, c.y - 1))) edges.push("N");
    if (set.has(keyOf(c.x + 1, c.y))) edges.push("E");
    if (set.has(keyOf(c.x, c.y + 1))) edges.push("S");
    if (set.has(keyOf(c.x - 1, c.y))) edges.push("W");
    out.set(keyOf(c.x, c.y), edges);
  }
  return out;
}

export function mergeNetworks(args: { road?: Cell[]; river?: Cell[] }): Map<string, NetworkConnectors> {
  const roadEdges = args.road ? deriveEdges(args.road) : null;
  const riverEdges = args.river ? deriveEdges(args.river) : null;

  const allKeys = new Set<string>();
  roadEdges?.forEach((_, k) => allKeys.add(k));
  riverEdges?.forEach((_, k) => allKeys.add(k));

  const out = new Map<string, NetworkConnectors>();
  for (const k of allKeys) {
    const road = roadEdges?.get(k);
    const river = riverEdges?.get(k);
    out.set(k, {
      ...(road && road.length ? { road } : {}),
      ...(river && river.length ? { river } : {}),
    });
  }
  return out;
}
```

Also include a UI-only demo layout in the same file or `src/lib/ui/networks.demo.ts`:

```ts
export const DEMO_NETWORKS = {
  road: [
    { x: 2, y: 6 }, { x: 3, y: 6 }, { x: 4, y: 6 }, { x: 5, y: 6 },
    { x: 5, y: 7 }, { x: 5, y: 8 },
  ],
  river: [
    { x: 9, y: 2 }, { x: 9, y: 3 }, { x: 9, y: 4 }, { x: 8, y: 4 }, { x: 7, y: 4 },
  ],
};
```

---

## 3) Wire overlays into `src/components/IsometricBoard.tsx`

We keep ground-only. We just add optional overlays.

### 3.1 Import helpers

At top:

```ts
import { DEMO_NETWORKS, edgeKey, mergeNetworks } from "@/lib/ui/networks";
```

### 3.2 Build connectors map once per render

Near top of component:

```ts
const connectorsByPos = mergeNetworks(DEMO_NETWORKS);
```

### 3.3 Render overlays per tile (road + river)

Inside the tile loop, after rendering the ground tile `<Box component="img" src="/assets/tiles/ground.png" ... />`,
render up to two overlay images.

Add right after the ground tile push:

```tsx
const connectors = connectorsByPos.get(`${x},${y}`);

function overlaySrc(kind: "road" | "river") {
  const edges = connectors?.[kind];
  const k = edgeKey(edges);
  if (!k) return null;
  return `/assets/tiles/networks/${kind}_${k}.png`;
}

const roadSrc = overlaySrc("road");
const riverSrc = overlaySrc("river");

// IMPORTANT: use integer zIndex spacing so overlays sit between base and highlights.
const baseZ = (x + y) * 3;

tiles.push(
  <Box
    key={`tile-${x}-${y}`}
    component="img"
    draggable={false}
    alt="Ground tile"
    src="/assets/tiles/ground.png"
    onDragStart={(event) => event.preventDefault()}
    sx={{
      position: "absolute",
      left,
      top,
      width: TILE_W,
      height: TILE_H,
      zIndex: baseZ,
      userSelect: "none",
      WebkitUserDrag: "none",
      transition: "filter 120ms ease",
      "&:hover": { filter: "brightness(1.15) saturate(1.4) hue-rotate(-20deg)" },
    }}
  />
);

// River under road if both exist
if (riverSrc) {
  tiles.push(
    <Box
      key={`river-${x}-${y}`}
      component="img"
      draggable={false}
      alt="River overlay"
      src={riverSrc}
      sx={{
        position: "absolute",
        left,
        top,
        width: TILE_W,
        height: TILE_H,
        zIndex: baseZ + 1,
        pointerEvents: "none",
        userSelect: "none",
        WebkitUserDrag: "none",
        // safety clip: keep top-face only even if future assets drift
        clipPath: "polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)",
      }}
    />
  );
}

if (roadSrc) {
  tiles.push(
    <Box
      key={`road-${x}-${y}`}
      component="img"
      draggable={false}
      alt="Road overlay"
      src={roadSrc}
      sx={{
        position: "absolute",
        left,
        top,
        width: TILE_W,
        height: TILE_H,
        zIndex: baseZ + 2,
        pointerEvents: "none",
        userSelect: "none",
        WebkitUserDrag: "none",
        clipPath: "polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)",
      }}
    />
  );
}
```

### 3.4 Update highlight zIndex to match new spacing

In your highlights mapping, change:

```ts
const zIndex = pos.x + pos.y + 1;
```

to:

```ts
const zIndex = (pos.x + pos.y) * 3 + 5;
```

(so it stays above overlays)

And for ground tiles in the loop, set `zIndex: baseZ` instead of `x + y`.

Units already use `+ 1000` so they remain above everything.

---

## 4) Add a script entry (optional but recommended)

In `package.json` add:

```json
"gen:tiles": "node scripts/gen_terrain_tiles.mjs"
```

---

## 5) Acceptance checks (non-negotiable)

* Road/river join perfectly across adjacent tiles for all combinations (straight, corner, T, X).
* Overlays affect only the diamond top face (no side faces).
* No lighting, no gradients, no noise, no texture, no glow.
* Game runs unchanged. Engine untouched.
* Expandability: adding `trench` later is:

    * add one entry to `NETWORKS` in the generator
    * add one key in `NetworkConnectors` + demo data
    * render it like road/river

---

## Extra: make it “exceptional”

If you have time, add a small “network manifest” file generated by the script for Codex-friendliness:

* `public/assets/tiles/networks/manifest.json`
  containing:

```json
{ "road": ["N","E","S","W","NE","NS","..."], "river": [...] }
```

This removes guesswork when mapping connectors → filenames later.

```
