````markdown
# CODEX REMEDIATION TASK — Fix ROAD/RIVER network tiles to match isometric top-face perspective (no more “flat bars”)

## Context (what went wrong)
Current `public/assets/tiles/networks/*.png` were generated by `scripts/gen_terrain_tiles.mjs` using **axis-aligned screen-space rectangles** (`fillRect`) and a diamond mask.  
Result: roads/rivers render as flat horizontal/vertical bars that do **not** follow the isometric tile face, and they don’t read as “on the tile surface”.

We must regenerate the network PNGs using the **same isometric top-face basis** used by terrain/highlight generation (the `rectOnTopFace()` approach with vectors `a` and `b`), so everything sits *in perspective* on the diamond face and joins perfectly across tiles.

IMPORTANT: runtime still uses only `/assets/tiles/ground.png` for base. Network images are overlays, but must be drawn in correct tile-face perspective.

Do NOT change engine logic/reducers/phases. This is generator + UI-only.

---

## Goal
Rewrite `makeNetworkOverlayTopFace()` in `scripts/gen_terrain_tiles.mjs` so ROAD and RIVER overlays are drawn as **parallelogram strips on the isometric top face**, connecting the **center** to the **edge midpoints** that correspond to grid adjacency directions.

Then regenerate:
- `public/assets/tiles/networks/road_<KEY>.png`
- `public/assets/tiles/networks/river_<KEY>.png`
and keep `manifest.json` consistent.

---

## Critical geometry rules (must match existing tile generator)
Use the same top-face coordinate basis as the terrain tiles:

- Define top-face corners:
  - `top  = (cx, cy - tileH/2)`
  - `right = (cx + tileW/2, cy)`
  - `bottom = (cx, cy + tileH/2)`
  - `left = (cx - tileW/2, cy)`
- Define basis vectors:
  - `a = right - top`
  - `b = left  - top`
- Any point on top face is:
  - `P(s,t) = top + a*s + b*t`, where `s,t in [0..1]`

Define helper (same style as other tiles):
```js
function rectOnTopFace(top, a, b, s0, s1, t0, t1) {
  return [
    { x: top.x + a.x * s0 + b.x * t0, y: top.y + a.y * s0 + b.y * t0 },
    { x: top.x + a.x * s1 + b.x * t0, y: top.y + a.y * s1 + b.y * t0 },
    { x: top.x + a.x * s1 + b.x * t1, y: top.y + a.y * s1 + b.y * t1 },
    { x: top.x + a.x * s0 + b.x * t1, y: top.y + a.y * s0 + b.y * t1 },
  ];
}
````

---

## Direction mapping (VERY IMPORTANT)

Your board’s `gridToScreen()` uses:

* `sx = (x - y) * (TILE_W/2)`
* `sy = (x + y) * stepY`

So “grid N/E/S/W adjacency” corresponds to these **diamond edge midpoints**:

* `N` (neighbor at y-1) = **top-right edge midpoint**  => param midpoint `(s=0.5, t=0)`
* `E` (neighbor at x+1) = **right-bottom edge midpoint** => `(s=1, t=0.5)`
* `S` (neighbor at y+1) = **bottom-left edge midpoint**  => `(s=0.5, t=1)`
* `W` (neighbor at x-1) = **left-top edge midpoint**     => `(s=0, t=0.5)`

We will draw connector strips from the center `(s=0.5,t=0.5)` to those edge midpoints.

---

## Implementation change: REPLACE `makeNetworkOverlayTopFace()` ONLY

### 1) Remove usage of `fillRect` inside network overlays

Network overlays must use `fillPolygon` + `rectOnTopFace` only (same style as the rest of the generator).

### 2) Replace `makeNetworkOverlayTopFace()` with the parametric top-face version

Implement this exact approach:

* Convert `widthPx` (pixel width) to normalized param width:

    * `w = widthPx / tileW`
    * `half = w / 2`
* Always draw a **center join plate** (a small square around (0.5,0.5)) so corners/T/X don’t get pinholes.
* For each edge in `edges`:

    * add one rectangular strip on top face using `rectOnTopFace()`.

#### Strips in (s,t) space (these are the canonical rectangles)

Let `c = 0.5`:

* Center join:

    * `s: [c-half, c+half]`
    * `t: [c-half, c+half]`

* `N` strip (to t=0, s=0.5):

    * `s: [c-half, c+half]`
    * `t: [0, c]`

* `S` strip:

    * `s: [c-half, c+half]`
    * `t: [c, 1]`

* `E` strip:

    * `s: [c, 1]`
    * `t: [c-half, c+half]`

* `W` strip:

    * `s: [0, c]`
    * `t: [c-half, c+half]`

For ROAD:

* draw outer strip fill (net.color)
* then inner strip fill (net.innerColor) with reduced width multiplier (e.g. 0.68)

For RIVER:

* same, but treat it as “channel” (still just flat fills), slightly wider.

### 3) Keep `applyTopFaceMask()` as a final safety gate

Keep masking to top diamond after drawing (it’s fine as extra hard gate), but the main correctness should come from drawing in top-face param space.

---

## Concrete code patch (write it)

In `scripts/gen_terrain_tiles.mjs`:

1. Keep `fillPolygon()` and `applyTopFaceMask()` as-is.
2. Add `rectOnTopFace()` helper near network code.
3. Replace `makeNetworkOverlayTopFace()` with the following logic (you can write your own code, but MUST follow the param rectangles and direction mapping above).

After this, re-run:

```bash
node scripts/gen_terrain_tiles.mjs
```

This must overwrite:

* `public/assets/tiles/networks/*.png`
* `public/assets/tiles/networks/manifest.json`

---

## UI check (minimal)

Do NOT change board rendering logic (z-order etc already OK).
Just verify visually in the running game:

* ROAD segments appear as diagonal/isometric strips aligned to the diamond face (not screen-horizontal bars)
* RIVER segments appear as wider channels aligned to the face
* Corner/T/X junctions look “welded” (no holes at center)
* Connections meet perfectly across adjacent tiles (no offsets)

If any segment looks screen-axis-aligned, the fix is NOT done.

---

## Expandability requirement

Keep the generator structured so adding `trench` later is:

* add one entry to `NETWORKS` array (id + widths + colors)
* no new geometry code

Do NOT hardcode road/river cases outside the `NETWORKS` entries.

---

## Deliverables

* Updated `scripts/gen_terrain_tiles.mjs` (fixed network generation)
* Regenerated PNGs in `public/assets/tiles/networks/`
* Updated `public/assets/tiles/networks/manifest.json`
* No changes to engine/reducers/phases

```
